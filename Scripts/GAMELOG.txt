/*
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                         GAME JAM 2 - GAMELOG                             â•‘
â•‘                    Arquitectura de Software en Tiempo Real                â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ÃšLTIMA ACTUALIZACIÃ“N: 8 de Noviembre de 2025 - 22:45
ARQUITECTO: GitHub Copilot
ESTADO: ï¿½ FASE 1 EN PROGRESO (GameManager + EventManager creados)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“‹ VISIÃ“N DEL PROYECTO
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

TIPO: Plataformero Lineal con Decisiones Branching
FORMATO: Cada CSV = un mapa de plataformero (tipo Mario)
PROGRESIÃ“N: Lineal (Nivel 1 â†’ 2 â†’ 3 â†’ ...) pero con ramas de finales
FINALES: BUENO/MALO crean ramificaciones narrativas en JSON

FLUJO:
  Nivel 1 (CSV) â†’ Nivel 2 (CSV) â†’ Nivel 3 [BOSS PAR] â†’ 
    â””â”€ DecisiÃ³n BUENO/MALO â†’ Desbloquea final especÃ­fico â†’ 
      Nivel 4 â†’ Nivel 5 â†’ Nivel 6 [BOSS PAR] â†’ ...

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âœ… CONFIRMACIONES DEL USUARIO
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

âœ“ JSON es suficiente (no usar ScriptableObject)
âœ“ Upgrades son PERMANENTES entre niveles
âœ“ Cada Boss tiene ESENCIA DIFERENTE y comportamiento Ãºnico
âœ“ Enemigos tienen DIFERENTES comportamientos por tipo (X, Y, Z, V)
âœ“ Hay sprites de algunos bosses
âœ“ Hay MÃšSICA POR ZONA y MÃšSICA POR BOSS
âœ“ Dash debe hacer INTANGIBLE al jugador durante ejecuciÃ³n
âœ“ Dash eleva (parÃ¡metros Y ya configurables)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ—ï¸ ARQUITECTURA ACORDADA
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

PILLARES PRINCIPALES:
  1. GameManager (singleton) - Estado global centralizado
  2. EventManager - ComunicaciÃ³n desacoplada entre sistemas
  3. SaveManager - Persistencia JSON Ãºnica
  4. BaseBoss (clase abstracta) - PatrÃ³n para todos los bosses
  5. BaseEnemy (clase abstracta) - PatrÃ³n para todos los enemigos
  6. Interfaces: IDamageable, IEnemy, IBoss

ESTRUCTURA DE CARPETAS:
  Assets/Scripts/
  â”œâ”€â”€ Core/
  â”‚   â”œâ”€â”€ GameManager.cs [TODO: CREAR]
  â”‚   â”œâ”€â”€ EventManager.cs [TODO: CREAR]
  â”‚   â”œâ”€â”€ GameState.cs [TODO: CREAR]
  â”‚   â””â”€â”€ GameEvents.cs [TODO: CREAR]
  â”‚
  â”œâ”€â”€ Interfaces/
  â”‚   â”œâ”€â”€ IDamageable.cs [TODO: CREAR]
  â”‚   â””â”€â”€ IEnemy.cs [TODO: CREAR]
  â”‚
  â”œâ”€â”€ Managers/
  â”‚   â”œâ”€â”€ SaveManager.cs [TODO: REFACTORIZAR]
  â”‚   â”œâ”€â”€ AudioManager.cs [TODO: CREAR]
  â”‚   â””â”€â”€ LevelManager.cs [TODO: REFACTORIZAR GeneradorNivel]
  â”‚
  â”œâ”€â”€ Entities/
  â”‚   â”œâ”€â”€ Base/
  â”‚   â”‚   â”œâ”€â”€ BaseEnemy.cs [TODO: CREAR - extraer de EnemyController]
  â”‚   â”‚   â””â”€â”€ BaseBoss.cs [TODO: CREAR - extraer de Boss.cs]
  â”‚   â”‚
  â”‚   â”œâ”€â”€ Enemy/
  â”‚   â”‚   â”œâ”€â”€ BasicEnemy.cs [TODO: CREAR - hereda BaseEnemy]
  â”‚   â”‚   â”œâ”€â”€ FastEnemy.cs [TODO: CREAR - hereda BaseEnemy]
  â”‚   â”‚   â”œâ”€â”€ StrongEnemy.cs [TODO: CREAR - hereda BaseEnemy]
  â”‚   â”‚   â””â”€â”€ FlyingEnemy.cs [TODO: CREAR - hereda BaseEnemy]
  â”‚   â”‚
  â”‚   â”œâ”€â”€ Boss/
  â”‚   â”‚   â”œâ”€â”€ Boss1.cs [TODO: REFACTORIZAR - hereda BaseBoss]
  â”‚   â”‚   â””â”€â”€ FinalBoss.cs [TODO: REFACTORIZAR - hereda BaseBoss]
  â”‚   â”‚
  â”‚   â””â”€â”€ Player/
  â”‚       â”œâ”€â”€ PlayerController.cs [REFACTORIZAR]
  â”‚       â””â”€â”€ PlayerDash.cs [TODO: SEPARAR LÃ“GICA]
  â”‚
  â””â”€â”€ Level/
      â”œâ”€â”€ LevelGenerator.cs [EXISTE - renombrar GeneradorNivel]
      â””â”€â”€ LevelTransition.cs [TODO: CREAR]

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“Š ESTRUCTURA JSON FINAL
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

{
  "nivelActual": 1,
  "finalBueno": 0,
  "finalMalo": 0,
  "boss1Derrotado": false,
  "boss2Derrotado": false,
  "pendingBoss": false,
  "upgrades": {
    "maxHealthUpgrades": 2,
    "weaponDamageUpgrades": 1,
    "specialAbilities": ["dash_enhanced"]
  },
  "playerStats": {
    "currentHealth": 100,
    "maxHealth": 150,
    "currentWeaponDamage": 10
  },
  "completedZones": [1, 2, 3],
  "playTime": 3600
}

CAMBIOS CRÃTICOS:
  - NO MÃS duplicaciÃ³n de SaveData en 4 archivos
  - UNA ÃšNICA definiciÃ³n en SaveManager.cs
  - Upgrades persist entre niveles
  - Cada boss tiene su flag especÃ­fico

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ® CAMBIOS EN MECÃNICAS
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

DASH MEJORADO:
  âœ“ Ya tiene parÃ¡metros Y (dashSpeedY)
  âœ“ FALTA: Hacer intangible (no ser tocado por enemigos)
  âœ“ FALTA: Propagar isIntangible a EnemyController y Boss

INTANGIBILIDAD EN DASH:
  ImplementaciÃ³n:
    1. ControlesPersonaje.isIntangible (bool privado)
    2. Cuando Dash() inicia: isIntangible = true
    3. Cuando Dash() termina: isIntangible = false
    4. EnemyController.Attack() chequea: if (player.IsIntangible) return;
    5. Boss.cs hace lo mismo
  
  Impacto: Dash se vuelve Ãºtil defensivamente, no solo ofensivo

UPGRADES PERMANENTES:
  Tipos:
    - Health upgrades (aumentan maxHealth)
    - Weapon upgrades (aumentan damage)
    - Special abilities (nuevas mecÃ¡nicas)
  
  CÃ³mo se aplican:
    1. Se encuentran en niveles o se dropean bosses
    2. Se guardan en JSON
    3. Se cargan al iniciar nivel siguiente
    4. Persistent entre niveles

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ¯ SISTEMA DE EVENTOS (EventManager)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

EVENTOS CRÃTICOS:
  - BossDefeatedEvent â†’ Boss1 o Boss2 muere â†’ Notifica GeneradorNivel
  - LevelCompleteEvent â†’ Jugador toca meta (E) â†’ Inicia transiciÃ³n
  - PlayerTakeDamageEvent â†’ Jugador recibe daÃ±o â†’ Actualiza HUD
  - UpgradeFoundEvent â†’ Jugador pickea upgrade â†’ Aplica stats
  - DecisionMadeEvent â†’ Jugador elige BUENO/MALO â†’ Desbloquea rama

FLUJO DE EVENTOS:
  Boss.Die() â†’ BossDefeatedEvent â†’ EventManager.Broadcast()
                                 â†’ ProgressionManager.DefeatBoss()
                                 â†’ GeneradorNivel.OnBossDefeated()
                                 â†’ Siguiente nivel se carga

VENTAJA: Acoplamiento mÃ­nimo, fÃ¡cil de debuggear

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ› BUGS CONOCIDOS A REPARAR
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ”´ CRÃTICO:
  1. SaveData duplicada en 4 archivos â†’ Puede perder datos
     SOLUCIÃ“N: Centralizar en GameManager + SaveManager
  
  2. Dash NO es intangible â†’ Enemigos atacan durante dash
     SOLUCIÃ“N: Agregar isIntangible a ControlesPersonaje + checkear en enemigos
  
  3. FinalBoss.cs estÃ¡ vacÃ­o â†’ Necesita implementaciÃ³n
     SOLUCIÃ“N: Crear BaseBoss, heredar en FinalBoss

ğŸŸ¡ IMPORTANTE:
  4. EnemyController sin interfaz â†’ CÃ³digo duplicado
     SOLUCIÃ“N: Crear BaseEnemy, IEnemy interface
  
  5. Paredes y fondos renderean en negro â†’ Shader issues
     SOLUCIÃ“N: Aplicado en Ãºltima actualizaciÃ³n (material instances)
  
  6. Sin AudioManager â†’ MÃºsica no sincronizada
     SOLUCIÃ“N: Crear AudioManager con EventManager

ğŸŸ¢ COMPLETADO:
  âœ“ ParametrizaciÃ³n dash (dashSpeedX, dashSpeedY)
  âœ“ CategorizaciÃ³n enemigos (X, Y, Z, V)
  âœ“ Sistema de guardado base
  âœ“ CinemÃ¡ticas intro/finales

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸš€ ROADMAP DE IMPLEMENTACIÃ“N (FASES)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

FASE 1: CENTRALIZACIÃ“N (ï¿½ EN PROGRESO - START HERE)
  â±ï¸ 2-3 horas
  âœ… Crear GameManager.cs (singleton) - HECHO
  âœ… Crear EventManager.cs - HECHO (bonificaciÃ³n: eventos completos)
  â³ Crear SaveManager.cs mejorado (integrar en GameManager)
  â³ Refactorizar NewGame.cs â†’ usa GameManager
  â³ Refactorizar Continue.cs â†’ usa GameManager
  â³ Refactorizar Finish.cs â†’ usa GameManager
  â³ Refactorizar GeneradorNivel.cs â†’ usa GameManager + eventos
  
  RESULTADO: SaveData centralizado, sincronizado siempre
  CRITERIO DE Ã‰XITO: Completar nivel, guardar, cerrar, continuar = sin perder datos
  
  PRÃ“XIMOS PASOS:
    1. Refactorizar NewGame.cs para usar GameManager.CreateNewGame()
    2. Refactorizar Continue.cs para usar GameManager.HasSaveFile()
    3. Refactorizar Finish.cs para usar GameManager.ProgressToNextLevel()
    4. Conectar GeneradorNivel con EventManager (escuchar BossDefeatedEvent)

FASE 2: EVENTOS Y COMUNICACIÃ“N
  â±ï¸ 1-2 horas
  âœ“ Crear EventManager.cs
  âœ“ Crear GameEvents.cs (todos los eventos)
  âœ“ Conectar Boss.Die() â†’ BossDefeatedEvent
  âœ“ Conectar Finish.OnTriggerEnter() â†’ LevelCompleteEvent
  âœ“ GeneradorNivel escucha BossDefeatedEvent
  
  RESULTADO: Sistemas desacoplados, fÃ¡cil de mantener
  CRITERIO DE Ã‰XITO: Boss muere â†’ evento â†’ nivel siguiente carga automÃ¡ticamente

FASE 3: INTERFACES E INTANGIBILIDAD
  â±ï¸ 1 hora
  âœ“ Crear IDamageable.cs
  âœ“ Crear IEnemy.cs
  âœ“ Implementar en EnemyController
  âœ“ Implementar en Boss.cs
  âœ“ Implementar en FinalBoss.cs
  âœ“ Agregar isIntangible a ControlesPersonaje
  âœ“ Chequear isIntangible en enemigos (no atacar)
  
  RESULTADO: Dash es defensivo, enemigos respetan intangibilidad
  CRITERIO DE Ã‰XITO: Dash durante ataque â†’ enemigo no toca â†’ no recibe daÃ±o

FASE 4: CLASE HIERARCHY DE BOSSES
  â±ï¸ 2 horas
  âœ“ Crear BaseBoss.cs (patrÃ³n abstracto)
  âœ“ Refactorizar Boss.cs â†’ hereda de BaseBoss
  âœ“ Refactorizar FinalBoss.cs â†’ hereda de BaseBoss
  âœ“ Cada boss implementa: Enter(), Phase1(), Phase2(), OnDefeated()
  
  RESULTADO: Bosses consistentes, esencia propia, extensibles
  CRITERIO DE Ã‰XITO: Puedes agregar Boss3 sin copy-paste

FASE 5: CLASE HIERARCHY DE ENEMIGOS
  â±ï¸ 2-3 horas
  âœ“ Crear BaseEnemy.cs (extraer lÃ³gica comÃºn de EnemyController)
  âœ“ Crear BasicEnemy.cs â†’ hereda de BaseEnemy
  âœ“ Crear FastEnemy.cs â†’ hereda, mÃ¡s velocidad, menos vida
  âœ“ Crear StrongEnemy.cs â†’ hereda, mÃ¡s vida, menos velocidad
  âœ“ Crear FlyingEnemy.cs â†’ hereda, diferente fÃ­sica (no gravity)
  âœ“ Actualizar GeneradorNivel para usar prefabs correctos
  
  RESULTADO: 4 tipos de enemigos con comportamientos distintos
  CRITERIO DE Ã‰XITO: CSV con X, Y, Z, V â†’ cada uno se comporta diferente

FASE 6: UPGRADES PERMANENTES
  â±ï¸ 2 horas
  âœ“ Crear Collectible.cs (base para items)
  âœ“ Crear HealthUpgrade.cs
  âœ“ Crear WeaponUpgrade.cs
  âœ“ Guardar upgrades en SaveData
  âœ“ Cargar upgrades al iniciar nivel
  âœ“ Aplicar stats del upgrade al jugador
  
  RESULTADO: ProgresiÃ³n vertical (mejoras permanentes)
  CRITERIO DE Ã‰XITO: Tomar upgrade â†’ guardar â†’ cargar â†’ upgrade persiste

FASE 7: AUDIO MANAGER
  â±ï¸ 1-2 horas
  âœ“ Crear AudioManager.cs
  âœ“ MÃºsica por zona (nivel 1, 2, 3, etc.)
  âœ“ MÃºsica por boss
  âœ“ SFX para acciones (salto, ataque, daÃ±o)
  âœ“ Conectar con EventManager
  
  RESULTADO: Audio sincronizado, dinÃ¡mico
  CRITERIO DE Ã‰XITO: Cambiar de nivel â†’ mÃºsica cambia automÃ¡ticamente

FASE 8: PULIDO Y OPTIMIZACIÃ“N
  â±ï¸ 2-3 horas
  âœ“ Camera bounds mejorados
  âœ“ Transiciones suaves entre niveles
  âœ“ Logging para debugging
  âœ“ Performance optimization
  âœ“ Testing en mÃºltiples intentos
  
  RESULTADO: Juego puliddo, sin bugs visibles
  CRITERIO DE Ã‰XITO: Completar todo el juego sin crashes

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“ NOTAS TÃ‰CNICAS IMPORTANTES
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

SINGLETON PATTERN:
  GameManager, SaveManager, EventManager usan singleton
  
  ImplementaciÃ³n segura:
    public static GameManager Instance { get; private set; }
    
    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
        DontDestroyOnLoad(gameObject);
    }
  
  Ventaja: Accesible desde cualquier lado como GameManager.Instance

HERENCIA VS INTERFAZ:
  BaseEnemy (herencia) â†’ comparte lÃ³gica comÃºn (patrullaje, detecciÃ³n)
  IEnemy (interfaz) â†’ contrato mÃ­nimo (TakeDamage, GetHealth)
  
  Enemigo implementa: class FastEnemy : BaseEnemy, IEnemy

JSON SERIALIZATION:
  Usar JsonUtility de Unity (nativo, sin dependencias)
  
  Estructura:
    [System.Serializable]
    public class SaveData
    {
        public int nivelActual;
        public bool boss1Derrotado;
        // etc
    }
    
    string json = JsonUtility.ToJson(data, true);
    File.WriteAllText(path, json);

EVENTOS:
  Broadcast â†’ Publisher notifica, no sabe quiÃ©n escucha
  Subscribe â†’ Listener se registra, se notifica automÃ¡ticamente
  
  Ejemplo:
    EventManager.Subscribe<BossDefeatedEvent>(HandleBoss);
    EventManager.Broadcast(new BossDefeatedEvent { bossId = "boss1" });

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ¬ PRÃ“XIMOS PASOS INMEDIATOS
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

PRIORIDAD 1 (HOY):
  â†’ Crear GameManager.cs
  â†’ Crear SaveManager.cs mejorado
  â†’ Centralizar SaveData
  â†’ Refactorizar NewGame.cs, Continue.cs, Finish.cs
  
  IMPACTO: Elimina bug crÃ­tico de SaveData inconsistente

PRIORIDAD 2 (MAÃ‘ANA):
  â†’ Crear EventManager.cs
  â†’ Conectar Boss.Die() con evento
  â†’ GeneradorNivel escucha evento
  
  IMPACTO: Acoplamiento dÃ©bil, fÃ¡cil de debuggear

PRIORIDAD 3 (DESPUÃ‰S):
  â†’ Intangibilidad en Dash
  â†’ Interfaces (IDamageable, IEnemy)
  â†’ BaseBoss + BasEnemy
  â†’ Esto ya es refactoring, el juego sigue funcionando

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“ CONTACTO CON ARQUITECTO
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Cuando ejecutes cÃ³digo de las FASES:
  1. Copia exactamente el cÃ³digo sugerido
  2. Si algo no compila â†’ error specific, reporta
  3. Si algo no funciona â†’ comportamiento inesperado, reporta
  4. Siempre consulta este GAMELOG antes de hacer cambios
  5. Actualiza este GAMELOG con tu progreso

TEMPLATE PARA REPORTES:
  FASE: [nÃºmero]
  ARCHIVO: [nombre]
  PROBLEMA: [descripciÃ³n]
  PASOS: [cÃ³mo reproducir]
  ERROR: [mensaje de consola]

â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âœ… LO QUE ESTÃ LISTO (CHECKPOINT 1)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

âœ… Core/GameManager.cs
   - SaveData centralizado (una Ãºnica definiciÃ³n)
   - CreateNewGame(), SaveGameState(), LoadGameState()
   - DefeatBoss(), AddUpgrade(), ProgressToNextLevel()
   - Singleton inicializa al Awake() y persiste entre escenas

âœ… Core/EventManager.cs
   - Sistema de eventos pub/sub completo
   - 11 eventos predefinidos
   - BossDefeatedEvent, LevelCompleteEvent, DecisionMadeEvent, etc.
   - Subscribe/Unsubscribe/Broadcast funcionan

âœ… PROXIMO_PASO_FASE1.txt
   - Instrucciones exactas para refactorizar cada archivo
   - Pseudo-cÃ³digo de cada cambio
   - Testing checklist
   - Errores comunes y soluciones

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ¯ PRÃ“XIMOS 5 PASOS
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

1. Verificar que GameManager y EventManager compilen
   - Buscar en Console: errores o warnings
   - Si hay: reportar exacto

2. Refactorizar en este orden:
   a) NewGame.cs â†’ GameManager.CreateNewGame() + DeleteSaveFile()
   b) Continue.cs â†’ GameManager.HasSaveFile()
   c) Boss.cs â†’ EventManager.Broadcast(BossDefeatedEvent)
   d) GeneradorNivel.cs â†’ EventManager.Subscribe() + GameManager.CurrentSave
   e) Finish.cs â†’ GameManager.ProgressToNextLevel() + Broadcast DecisionMadeEvent

3. Testear despuÃ©s de cada cambio (usar checklist en PROXIMO_PASO_FASE1.txt)

4. Si algo no compila â†’ reportar error exacto

5. Cuando todo compile y funcione â†’ FASE 1 COMPLETADA

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“Š ESTRUCTURA FINAL DE CARPETAS (lo que tendrÃ¡s cuando FASE 1 termine)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Assets/Scripts/
â”œâ”€â”€ Core/
â”‚   â”œâ”€â”€ GameManager.cs âœ… CREADO
â”‚   â”œâ”€â”€ EventManager.cs âœ… CREADO
â”‚   â””â”€â”€ (SaveManager.cs si lo separamos despuÃ©s)
â”‚
â”œâ”€â”€ (todos los demÃ¡s archivos existentes)
â”‚   â”œâ”€â”€ ControlesPersonaje.cs (mismo)
â”‚   â”œâ”€â”€ GeneradorNivel.cs (REFACTORIZADO â³)
â”‚   â”œâ”€â”€ Boss.cs (REFACTORIZADO â³)
â”‚   â”œâ”€â”€ NewGame.cs (REFACTORIZADO â³)
â”‚   â”œâ”€â”€ Continue.cs (REFACTORIZADO â³)
â”‚   â”œâ”€â”€ Finish.cs (REFACTORIZADO â³)
â”‚   â””â”€â”€ ... resto igual

CAMBIOS FUNCIONALES DESPUÃ‰S DE FASE 1:
  - SaveData nunca mÃ¡s se pierde (centralizado)
  - Sistemas desacoplados (usan eventos)
  - Boss derrotado â†’ evento â†’ siguiente nivel carga automÃ¡tico
  - Guardado sincronizado siempre

â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
*/
